-- =========================================================
-- 07_clean_yds_data.sql
-- Transform RAW.YDS_DATA -> RAW.YDS_TRANSFORMED (typed)
-- -> RAW.YDS_CLEANED (imputations + features)
-- =========================================================

-- Context
USE ROLE ACCOUNTADMIN;
USE WAREHOUSE COMPUTE_WH;
USE DATABASE SHOT_DATABASE;
USE SCHEMA RAW;

-- 1) Create a typed table from the landing table
-- Note: adjust columns to match your CSV header names
CREATE OR REPLACE TABLE SHOT_DATABASE.RAW.YDS_TRANSFORMED (
    INDEX_COL                  INT,
    MATCH_EVENT_ID_1           INT,
    LOCATION_X                 INT,
    LOCATION_Y                 INT,
    REMAINING_MIN_1            INT,
    POWER_OF_SHOT_1            INT,
    KNOCKOUT_MATCH_1           BOOLEAN,
    GAME_SEASON                VARCHAR(16),
    REMAINING_SEC_1            INT,
    DISTANCE_OF_SHOT_1         INT,
    IS_GOAL                    BOOLEAN,
    AREA_OF_SHOT               VARCHAR(50),
    SHOT_BASICS                VARCHAR(50),
    RANGE_OF_SHOT              VARCHAR(30),
    TEAM_NAME                  VARCHAR(100),
    DATE_OF_GAME               DATE,
    "home/away"                VARCHAR(40),
    SHOT_ID_NUMBER             INT,
    "lat/lng"                  VARCHAR(64),
    TYPE_OF_SHOT               VARCHAR(50),
    TYPE_OF_COMBINED_SHOT      VARCHAR(50),
    MATCH_ID                   BIGINT,
    TEAM_ID                    BIGINT,
    REMAINING_MIN_2            NUMBER(18,4),
    POWER_OF_SHOT_2            NUMBER(18,4),
    KNOCKOUT_MATCH_2           NUMBER(18,4),
    REMAINING_SEC_2            NUMBER(18,4),
    DISTANCE_OF_SHOT_2         NUMBER(18,4)
);

-- 2) Insert with safe casts from the raw table
-- Map your source columns exactly; keep TRY_* to avoid hard failures
INSERT OVERWRITE INTO SHOT_DATABASE.RAW.YDS_TRANSFORMED
SELECT
    TRY_TO_NUMBER(INDEX_COL)::INT,
    TRY_TO_NUMBER(MATCH_EVENT_ID)::INT,
    TRY_TO_NUMBER(LOCATION_X)::INT,
    TRY_TO_NUMBER(LOCATION_Y)::INT,
    TRY_TO_NUMBER(REMAINING_MIN_1)::INT,
    TRY_TO_NUMBER(POWER_OF_SHOT_1)::INT,
    TRY_TO_NUMBER(KNOCKOUT_MATCH_1)::INT <> 0,
    GAME_SEASON,
    TRY_TO_NUMBER(REMAINING_SEC_1)::INT,
    TRY_TO_NUMBER(DISTANCE_OF_SHOT_1)::INT,
    TRY_TO_NUMBER(IS_GOAL)::INT <> 0,
    AREA_OF_SHOT,
    SHOT_BASICS,
    RANGE_OF_SHOT,
    TEAM_NAME,
    TRY_TO_DATE(DATE_OF_GAME, 'YYYY-MM-DD'),
    "home/away",
    TRY_TO_NUMBER(SHOT_ID_NUMBER)::INT,
    "lat/lng",
    TYPE_OF_SHOT,
    TYPE_OF_COMBINED_SHOT,
    TRY_TO_NUMBER(MATCH_ID)::BIGINT,
    TRY_TO_NUMBER(TEAM_ID)::BIGINT,
    TRY_TO_NUMBER(REMAINING_MIN_2)::NUMBER(18,4),
    TRY_TO_NUMBER(POWER_OF_SHOT_2)::NUMBER(18,4),
    TRY_TO_NUMBER(KNOCKOUT_MATCH_2)::NUMBER(18,4),
    TRY_TO_NUMBER(REMAINING_SEC_2)::NUMBER(18,4),
    TRY_TO_NUMBER(DISTANCE_OF_SHOT_2)::NUMBER(18,4)
FROM SHOT_DATABASE.RAW.YDS_DATA;

-- 3) Create the working table for cleaning
CREATE OR REPLACE TABLE SHOT_DATABASE.RAW.YDS_CLEANED
CLONE SHOT_DATABASE.RAW.YDS_TRANSFORMED;

-- 4) Imputations that can be derived from the dataset

-- 4a) Impute SHOT_ID_NUMBER = INDEX_COL + 1 when missing
UPDATE SHOT_DATABASE.RAW.YDS_CLEANED
SET SHOT_ID_NUMBER = INDEX_COL + 1
WHERE SHOT_ID_NUMBER IS NULL AND INDEX_COL IS NOT NULL;

-- 4b) Impute DATE_OF_GAME within each MATCH_ID from existing non-null values
MERGE INTO SHOT_DATABASE.RAW.YDS_CLEANED AS T
USING (
  SELECT DISTINCT
    MATCH_ID,
    FIRST_VALUE(DATE_OF_GAME) IGNORE NULLS
      OVER (PARTITION BY MATCH_ID ORDER BY DATE_OF_GAME) AS FILLED_DATE
  FROM SHOT_DATABASE.RAW.YDS_CLEANED
) S
ON T.MATCH_ID = S.MATCH_ID
WHEN MATCHED AND T.DATE_OF_GAME IS NULL
THEN UPDATE SET T.DATE_OF_GAME = S.FILLED_DATE;

-- 4c) Impute GAME_SEASON from existing values by match, then fallback from DATE_OF_GAME
MERGE INTO SHOT_DATABASE.RAW.YDS_CLEANED AS T
USING (
  SELECT DISTINCT
    MATCH_ID,
    FIRST_VALUE(GAME_SEASON) IGNORE NULLS
      OVER (PARTITION BY MATCH_ID ORDER BY GAME_SEASON) AS FILLED_SEASON
  FROM SHOT_DATABASE.RAW.YDS_CLEANED
) S
ON T.MATCH_ID = S.MATCH_ID
WHEN MATCHED AND T.GAME_SEASON IS NULL
THEN UPDATE SET T.GAME_SEASON = S.FILLED_SEASON;

-- Fallback from DATE_OF_GAME if still null
UPDATE SHOT_DATABASE.RAW.YDS_CLEANED
SET GAME_SEASON =
  CASE
    WHEN MONTH(DATE_OF_GAME) >= 10
      THEN TO_VARCHAR(YEAR(DATE_OF_GAME)) || '-' || RIGHT(TO_VARCHAR(YEAR(DATE_OF_GAME) + 1), 2)
    ELSE TO_VARCHAR(YEAR(DATE_OF_GAME) - 1) || '-' || RIGHT(TO_VARCHAR(YEAR(DATE_OF_GAME)), 2)
  END
WHERE GAME_SEASON IS NULL AND DATE_OF_GAME IS NOT NULL;

-- 4d) Impute "home/away" within match from existing values
MERGE INTO SHOT_DATABASE.RAW.YDS_CLEANED AS T
USING (
  SELECT DISTINCT
    MATCH_ID,
    FIRST_VALUE("home/away") IGNORE NULLS
      OVER (PARTITION BY MATCH_ID ORDER BY "home/away") AS FILLED_HOME_AWAY
  FROM SHOT_DATABASE.RAW.YDS_CLEANED
) S
ON T.MATCH_ID = S.MATCH_ID
WHEN MATCHED AND T."home/away" IS NULL
THEN UPDATE SET T."home/away" = S.FILLED_HOME_AWAY;

-- 4e) Impute MATCH_EVENT_ID_1 by carry-forward within a match, starting at 1
MERGE INTO SHOT_DATABASE.RAW.YDS_CLEANED AS T
USING (
  WITH ordered AS (
    SELECT
      MATCH_ID,
      INDEX_COL,
      MATCH_EVENT_ID_1,
      LAST_VALUE(MATCH_EVENT_ID_1 IGNORE NULLS)
        OVER (PARTITION BY MATCH_ID ORDER BY INDEX_COL
              ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING) AS prev_val
    FROM SHOT_DATABASE.RAW.YDS_CLEANED
  )
  SELECT MATCH_ID, INDEX_COL, COALESCE(prev_val, 0) + 1 AS imputed_value
  FROM ordered
  WHERE MATCH_EVENT_ID_1 IS NULL
) S
ON T.MATCH_ID = S.MATCH_ID AND T.INDEX_COL = S.INDEX_COL
WHEN MATCHED THEN UPDATE SET T.MATCH_EVENT_ID_1 = S.IMPUTED_VALUE;

-- 4f) Impute time fields with simple rules
-- First, per-match integer average for REMAINING_MIN_1
MERGE INTO SHOT_DATABASE.RAW.YDS_CLEANED T
USING (
  SELECT MATCH_ID, FLOOR(AVG(REMAINING_MIN_1)) AS AVG_MIN
  FROM SHOT_DATABASE.RAW.YDS_CLEANED
  WHERE REMAINING_MIN_1 IS NOT NULL
  GROUP BY MATCH_ID
) S
ON T.MATCH_ID = S.MATCH_ID
WHEN MATCHED AND T.REMAINING_MIN_1 IS NULL
THEN UPDATE SET T.REMAINING_MIN_1 = S.AVG_MIN;

-- Then, global integer average to fill any leftovers
SET GLOBAL_AVG_MIN = (
  SELECT ROUND(AVG(REMAINING_MIN_1)) FROM SHOT_DATABASE.RAW.YDS_CLEANED WHERE REMAINING_MIN_1 IS NOT NULL
);
UPDATE SHOT_DATABASE.RAW.YDS_CLEANED
SET REMAINING_MIN_1 = $GLOBAL_AVG_MIN
WHERE REMAINING_MIN_1 IS NULL;

-- Fixed midpoint for seconds where missing
UPDATE SHOT_DATABASE.RAW.YDS_CLEANED
SET REMAINING_SEC_1 = 30
WHERE REMAINING_SEC_1 IS NULL;

-- 5) Feature engineering

-- 5a) OPPONENT_TEAM from "home/away" field
ALTER TABLE SHOT_DATABASE.RAW.YDS_CLEANED ADD COLUMN OPPONENT_TEAM VARCHAR(50);
UPDATE SHOT_DATABASE.RAW.YDS_CLEANED
SET OPPONENT_TEAM = TRIM(
  CASE
    WHEN "home/away" LIKE '%@%'  THEN SPLIT_PART("home/away", '@',  2)
    WHEN "home/away" LIKE '%vs.%' THEN SPLIT_PART("home/away", 'vs.', 2)
    ELSE NULL
  END
)
WHERE "home/away" IS NOT NULL;

-- 5b) ON_HOME boolean flag
ALTER TABLE SHOT_DATABASE.RAW.YDS_CLEANED ADD COLUMN ON_HOME BOOLEAN;
UPDATE SHOT_DATABASE.RAW.YDS_CLEANED
SET ON_HOME =
  CASE
    WHEN "home/away" LIKE '%vs.%' THEN TRUE
    WHEN "home/away" LIKE '%@%'  THEN FALSE
    ELSE NULL
  END
WHERE "home/away" IS NOT NULL;

-- 5c) Split lat/lng into numeric lat/long and drop combined column
ALTER TABLE SHOT_DATABASE.RAW.YDS_CLEANED ADD COLUMN LATITUDE  NUMBER(10,6);
ALTER TABLE SHOT_DATABASE.RAW.YDS_CLEANED ADD COLUMN LONGITUDE NUMBER(10,6);

UPDATE SHOT_DATABASE.RAW.YDS_CLEANED
SET
  LATITUDE  = TRY_TO_NUMBER(SPLIT_PART("lat/lng", ',', 1), 10, 6),
  LONGITUDE = TRY_TO_NUMBER(SPLIT_PART("lat/lng", ',', 2), 10, 6)
WHERE "lat/lng" IS NOT NULL;

ALTER TABLE SHOT_DATABASE.RAW.YDS_CLEANED DROP COLUMN "lat/lng";

-- 6) Quick verification
SELECT
  COUNT(*)                                               AS total_rows,
  COUNT_IF(REMAINING_MIN_1 IS NULL)                      AS null_remaining_min,
  COUNT_IF(REMAINING_SEC_1 IS NULL)                      AS null_remaining_sec,
  COUNT_IF(GAME_SEASON IS NULL)                          AS null_game_season,
  COUNT_IF(OPPONENT_TEAM IS NULL)                        AS null_opponent_team,
  COUNT_IF(LATITUDE IS NULL)                             AS null_latitude
FROM SHOT_DATABASE.RAW.YDS_CLEANED;

SELECT * FROM SHOT_DATABASE.RAW.YDS_CLEANED LIMIT 100;
